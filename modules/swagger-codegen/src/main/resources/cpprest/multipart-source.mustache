{{>licenseInfo}}
#include "MultipartFormData.h"
#include "ModelBase.h"

{{#modelNamespaceDeclarations}}
namespace {{this}} {
{{/modelNamespaceDeclarations}}

MultipartFormData::MultipartFormData()
{
    m_Boundary = createBoundary();
}

MultipartFormData::MultipartFormData(const utility::string_t& boundary)
    : m_Boundary(boundary)
{

}

MultipartFormData::~MultipartFormData()
{
}

utility::string_t MultipartFormData::getBoundary()
{
    return m_Boundary;
}

void MultipartFormData::add( std::shared_ptr<HttpContent> content )
{
    m_Contents.push_back( content );
    m_ContentLookup[content->getName()] = content;
}

bool MultipartFormData::hasContent(const utility::string_t& name) const
{
    return m_ContentLookup.find(name) != m_ContentLookup.end();
}

std::shared_ptr<HttpContent> MultipartFormData::getContent(const utility::string_t& name) const
{
    auto result = m_ContentLookup.find(name);
    if(result == m_ContentLookup.end())
    {
        return std::shared_ptr<HttpContent>(nullptr);
    }
    return result->second;
}

void MultipartFormData::writeTo( std::ostream& target )
{
    for ( size_t i = 0; i < m_Contents.size(); i++ )
    {
        std::shared_ptr<HttpContent> content = m_Contents[i];

        // boundary
        target << "\r\n" << "--" << utility::conversions::to_utf8string( m_Boundary ) << "\r\n";

        // headers
        target << "Content-Disposition: " << utility::conversions::to_utf8string( content->getContentDisposition() );
        if ( content->getName().size() > 0 )
        {
            target << "; name=\"" << utility::conversions::to_utf8string( content->getName() ) << "\"";
        }
        if ( content->getFileName().size() > 0 )
        {
            target << "; filename=\"" << utility::conversions::to_utf8string( content->getFileName() ) << "\"";
        }
        target << "\r\n";

        if ( content->getContentType().size() > 0 )
        {
            target << "Content-Type: " << utility::conversions::to_utf8string( content->getContentType() ) << "\r\n";
        }

        target << "\r\n";

        // body
        std::shared_ptr<std::istream> data = content->getData();

		data->seekg( 0, data->end );
		std::vector<char> dataBytes( data->tellg() );
		
		data->seekg( 0, data->beg );
		data->read( &dataBytes[0], dataBytes.size() );

		std::copy( dataBytes.begin(), dataBytes.end(), std::ostreambuf_iterator<char>( target ) );
    }

    target << "\r\n--" << utility::conversions::to_utf8string( m_Boundary ) << "--\r\n";
}

utility::string_t MultipartFormData::createBoundary()
{
    // fill GUID with random bytes
    std::mt19937 rnd(time(0));
    std::vector<unsigned char> guidData(16);
    for (size_t i = 0; i < guidData.size(); i++)
    {
        guidData[i] = rnd() % 256;
    }

    // convert random bytes into xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx format
    utility::char_t guidString[37]; // 32 hex chars + 4 hyphens + null terminator
    swprintf_s(
        guidString, sizeof(guidString) / sizeof(guidString[0]),
        L"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",

        guidData[0],
        guidData[1],
        guidData[2],
        guidData[3],

        guidData[4],
        guidData[5],

        guidData[6],
        guidData[7],

        guidData[8],
        guidData[9],

        guidData[10],
        guidData[11],
        guidData[12],
        guidData[13],
        guidData[14],
        guidData[15]
    );
    return guidString;
}

{{#modelNamespaceDeclarations}}
}
{{/modelNamespaceDeclarations}}
